### 反转单链表

  给定一个单链表的头结点pHead，长度为n，反转该链表后，返回新链表的表头。 

  数据范围： n≤1000n\leq1000n≤1000  

  要求：空间复杂度 O(1)O(1)O(1) ，时间复杂度 O(n)O(n)O(n) 。 

  如当输入链表{1,2,3}时， 

  经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。 

#### 思路解析

- 栈

  ```java
  /*
  public class ListNode {
      int val;
      ListNode next = null;
  
      ListNode(int val) {
          this.val = val;
      }
  }*/
  import java.util.Stack;
  public class Solution {
  public ListNode ReverseList(ListNode head) {
      Stack<ListNode> stack= new Stack<>();
      //把链表节点全部摘掉放到栈中
      while (head != null) {
          stack.push(head);
          head = head.next;
      }
      if (stack.isEmpty())
          return null;
      ListNode node = stack.pop();
      ListNode dummy = node;
      //栈中的结点全部出栈，然后重新连成一个新的链表
      while (!stack.isEmpty()) {
          ListNode tempNode = stack.pop();
          node.next = tempNode;
          node = node.next;
      }
      //最后一个结点就是反转前的头结点，一定要让他的next
      //等于空，否则会构成环
      node.next = null;
      return dummy;
  }
  }
  ```

- 双链表
  - 循环

  ```java
  /*
  public class ListNode {
      int val;
      ListNode next = null;
  
      ListNode(int val) {
          this.val = val;
      }
  }*/
  public class Solution {
      public ListNode ReverseList(ListNode head) {
          if(head==null || head.next==null){  //判断链表为空或长度为1的情况
               return head;
           }  
   		ListNode node = head;
          //prev作为每一个结点的前一个结点
          ListNode prev = null;
          
          while(node != null){
              //存储当前结点的下一个结点
              ListNode next = node.next;
              //将当前指针的结点指向前一个结点prev
              node.next = prev;
              //将当前结点作为下一个结点的前置结点
              prev = node;
              //将后置结点作为当前结点，来重复该动作
              node = next;
          }
          
          return prev;
      }
  }
  ```

  

  - 递归

  ```java
  /*
  public class ListNode {
      int val;
      ListNode next = null;
  
      ListNode(int val) {
          this.val = val;
      }
  }*/
  public class Solution {
      public ListNode ReverseList(ListNode head) {
          if(head==null || head.next==null){  //判断链表为空或长度为1的情况
               return head;
           }  
   		//保存当前节点的下一个结点
     		ListNode node = head.next;
      	//从当前节点的下一个结点开始递归调用
      	ListNode reverse = ReverseList(node);
      	//reverse是反转之后的链表，因为函数reverseList
          // 表示的是对链表的反转，所以反转完之后next肯定
          // 是链表reverse的尾结点，然后我们再把当前节点
          //head挂到node节点的后面就完成了链表的反转。
          node.next = head;
          //这里head相当于变成了尾结点，尾结点都是为空的，
          //否则会构成环
          head.next = null;
          return reverse;
      }
  }
  ```

  